/**
 * YouTube Transcript Extraction Module
 * Extracts video transcripts using YouTube's internal APIs
 */

const TranscriptExtractor = (() => {
  /**
   * Extract video ID from current URL
   */
  function getVideoId() {
    const url = new URL(window.location.href);
    return url.searchParams.get('v');
  }

  /**
   * Get caption tracks from YouTube's player response
   * Primary method: parse ytInitialPlayerResponse from page data
   */
  async function getCaptionTracks() {
    // Method 1: Try to get from ytInitialPlayerResponse global
    if (window.ytInitialPlayerResponse) {
      const tracks = extractTracksFromPlayerResponse(window.ytInitialPlayerResponse);
      if (tracks && tracks.length > 0) return tracks;
    }

    // Method 2: Try to find in page scripts
    const tracks = await extractTracksFromPageScripts();
    if (tracks && tracks.length > 0) return tracks;

    // Method 3: Fetch from YouTube's internal API
    return await fetchCaptionTracksFromAPI();
  }

  /**
   * Extract caption tracks from player response object
   */
  function extractTracksFromPlayerResponse(playerResponse) {
    try {
      const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer;
      if (!captions || !captions.captionTracks) return null;

      return captions.captionTracks.map((track) => ({
        baseUrl: track.baseUrl,
        language: track.languageCode,
        name: track.name?.simpleText || track.name?.runs?.[0]?.text || track.languageCode,
        isAutoGenerated: track.kind === 'asr',
        vssId: track.vssId
      }));
    } catch (e) {
      console.warn('[YT-AI-Summarizer] Error parsing player response:', e);
      return null;
    }
  }

  /**
   * Extract JSON starting from a given index using balanced brace matching
   */
  function extractBalancedJSON(text, startIdx) {
    const jsonStart = text.indexOf('{', startIdx);
    if (jsonStart === -1) return null;
    let depth = 0;
    for (let i = jsonStart; i < text.length; i++) {
      if (text[i] === '{') depth++;
      else if (text[i] === '}') {
        depth--;
        if (depth === 0) {
          try {
            return JSON.parse(text.substring(jsonStart, i + 1));
          } catch {
            return null;
          }
        }
      }
    }
    return null;
  }

  /**
   * Extract balanced JSON array starting from a given index
   */
  function extractBalancedArray(text, startIdx) {
    const arrStart = text.indexOf('[', startIdx);
    if (arrStart === -1) return null;
    let depth = 0;
    for (let i = arrStart; i < text.length; i++) {
      if (text[i] === '[') depth++;
      else if (text[i] === ']') {
        depth--;
        if (depth === 0) {
          try {
            return JSON.parse(text.substring(arrStart, i + 1));
          } catch {
            return null;
          }
        }
      }
    }
    return null;
  }

  /**
   * Extract tracks by parsing page script tags
   */
  async function extractTracksFromPageScripts() {
    try {
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const text = script.textContent;
        if (text && text.includes('"captionTracks"')) {
          const idx = text.indexOf('"captionTracks"');
          if (idx === -1) continue;
          // Find the colon after "captionTracks"
          const colonIdx = text.indexOf(':', idx + 15);
          if (colonIdx === -1) continue;

          const tracks = extractBalancedArray(text, colonIdx);
          if (tracks && Array.isArray(tracks) && tracks.length > 0) {
            return tracks.map((track) => ({
              baseUrl: track.baseUrl,
              language: track.languageCode,
              name: track.name?.simpleText || track.languageCode,
              isAutoGenerated: track.kind === 'asr',
              vssId: track.vssId
            }));
          }
        }
      }
    } catch (e) {
      console.warn('[YT-AI-Summarizer] Error parsing page scripts:', e);
    }
    return null;
  }

  /**
   * Fetch caption tracks from YouTube's watch endpoint
   */
  async function fetchCaptionTracksFromAPI() {
    try {
      const videoId = getVideoId();
      if (!videoId) return null;

      const response = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
        credentials: 'include'
      });

      if (!response.ok) return null;

      const html = await response.text();

      // Use balanced brace extraction instead of fragile regex
      const startIdx = html.indexOf('ytInitialPlayerResponse');
      if (startIdx !== -1) {
        const playerResponse = extractBalancedJSON(html, startIdx);
        if (playerResponse) {
          return extractTracksFromPlayerResponse(playerResponse);
        }
      }
    } catch (e) {
      console.warn('[YT-AI-Summarizer] Error fetching caption tracks:', e);
    }
    return null;
  }

  /**
   * Fetch and parse transcript from a caption track URL
   */
  async function fetchTranscriptFromUrl(trackUrl) {
    // Try JSON3 format first
    try {
      const url = new URL(trackUrl);
      url.searchParams.set('fmt', 'json3');

      const response = await fetch(url.toString());
      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const data = await response.json();

      if (data.events) {
        const entries = data.events
          .filter((event) => event.segs)
          .map((event) => {
            const startMs = event.tStartMs || 0;
            const text = event.segs
              .map((seg) => seg.utf8)
              .join('')
              .replace(/\n/g, ' ')
              .trim();

            return {
              start: startMs / 1000,
              startFormatted: formatTimestamp(startMs / 1000),
              text: text
            };
          })
          .filter((entry) => entry.text.length > 0);

        if (entries.length > 0) return entries;
      }
    } catch (e) {
      console.warn('[YT-AI-Summarizer] JSON transcript failed, trying XML:', e);
    }

    // Fallback: XML format (single attempt, no double-call)
    return await fetchTranscriptXML(trackUrl);
  }

  /**
   * Fetch transcript in XML format (fallback)
   */
  async function fetchTranscriptXML(trackUrl) {
    try {
      const response = await fetch(trackUrl);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const xmlText = await response.text();
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
      const textNodes = xmlDoc.querySelectorAll('text');

      return Array.from(textNodes).map((node) => {
        const start = parseFloat(node.getAttribute('start') || '0');
        // DOMParser already decodes XML entities in textContent
        const text = node.textContent.replace(/\n/g, ' ').trim();

        return {
          start,
          startFormatted: formatTimestamp(start),
          text
        };
      }).filter((entry) => entry.text.length > 0);
    } catch (e) {
      console.warn('[YT-AI-Summarizer] Error fetching XML transcript:', e);
      return null;
    }
  }

  /**
   * Format seconds to MM:SS or HH:MM:SS
   */
  function formatTimestamp(seconds) {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hrs > 0) {
      return `${hrs}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }
    return `${mins}:${String(secs).padStart(2, '0')}`;
  }

  /**
   * Select the best caption track based on user preference
   */
  function selectBestTrack(tracks, preferredLang = 'auto') {
    if (!tracks || tracks.length === 0) return null;

    if (preferredLang !== 'auto') {
      const exact = tracks.find(
        (t) => t.language === preferredLang && !t.isAutoGenerated
      );
      if (exact) return exact;

      const autoGen = tracks.find(
        (t) => t.language === preferredLang && t.isAutoGenerated
      );
      if (autoGen) return autoGen;
    }

    const manual = tracks.find((t) => !t.isAutoGenerated);
    if (manual) return manual;

    const english = tracks.find((t) => t.language === 'en');
    if (english) return english;

    return tracks[0];
  }

  /**
   * Main function: Get transcript for current video
   */
  async function getTranscript(preferredLang = 'auto') {
    const videoId = getVideoId();
    if (!videoId) {
      throw new Error('NO_VIDEO_ID');
    }

    // Check cache first
    const cached = await StorageHelper.getCachedTranscript(videoId);
    if (cached) {
      return cached;
    }

    const tracks = await getCaptionTracks();
    if (!tracks || tracks.length === 0) {
      throw new Error('NO_TRANSCRIPT');
    }

    const selectedTrack = selectBestTrack(tracks, preferredLang);
    if (!selectedTrack) {
      throw new Error('NO_TRANSCRIPT');
    }

    const entries = await fetchTranscriptFromUrl(selectedTrack.baseUrl);
    if (!entries || entries.length === 0) {
      throw new Error('EMPTY_TRANSCRIPT');
    }

    const fullText = entries.map((e) => e.text).join(' ');

    const result = {
      videoId,
      entries,
      fullText,
      language: selectedTrack.language,
      trackName: selectedTrack.name,
      isAutoGenerated: selectedTrack.isAutoGenerated,
      availableTracks: tracks.map((t) => ({
        language: t.language,
        name: t.name,
        isAutoGenerated: t.isAutoGenerated
      }))
    };

    await StorageHelper.cacheTranscript(videoId, result);
    return result;
  }

  /**
   * Get available languages for current video
   */
  async function getAvailableLanguages() {
    const tracks = await getCaptionTracks();
    if (!tracks) return [];
    return tracks.map((t) => ({
      code: t.language,
      name: t.name,
      isAutoGenerated: t.isAutoGenerated
    }));
  }

  return {
    getVideoId,
    getTranscript,
    getAvailableLanguages,
    formatTimestamp
  };
})();

if (typeof window !== 'undefined') {
  window.TranscriptExtractor = TranscriptExtractor;
}
