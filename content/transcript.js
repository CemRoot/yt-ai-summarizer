/**
 * YouTube Transcript Extraction Module
 * Extracts video transcripts using multiple fallback methods.
 *
 * Method priority:
 *  1. Page bridge (MAIN world) – uses YouTube's live player API
 *  2. Script-tag parsing – reads embedded JSON from the HTML
 *  3. Service-worker proxy – re-fetches the watch page server-side
 *
 * Transcript fetching:
 *  1. Direct fetch from content script (JSON3, then XML)
 *  2. Service-worker proxy fetch (bypasses potential CORS/redirect issues)
 */

const TranscriptExtractor = (() => {
  const LOG = '[YT-AI]';

  // ─── helpers ────────────────────────────────────────────────────────

  function getVideoId() {
    const url = new URL(window.location.href);
    return url.searchParams.get('v');
  }

  function formatTimestamp(seconds) {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    if (hrs > 0) {
      return `${hrs}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }
    return `${mins}:${String(secs).padStart(2, '0')}`;
  }

  function mapRawTrack(track) {
    return {
      baseUrl: track.baseUrl,
      language: track.languageCode,
      name: track.name?.simpleText || track.name?.runs?.[0]?.text || track.languageCode,
      isAutoGenerated: track.kind === 'asr',
      vssId: track.vssId
    };
  }

  function extractTracksFromPlayerResponse(playerResponse) {
    try {
      const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer;
      if (!captions?.captionTracks) return null;
      return captions.captionTracks.map(mapRawTrack);
    } catch (e) {
      console.warn(LOG, 'Error parsing player response:', e);
      return null;
    }
  }

  // ─── balanced JSON / array extraction (string-aware) ───────────────

  function extractBalancedJSON(text, startIdx) {
    const jsonStart = text.indexOf('{', startIdx);
    if (jsonStart === -1) return null;
    let depth = 0;
    let inString = false;
    let escaped = false;
    for (let i = jsonStart; i < text.length; i++) {
      const ch = text[i];
      if (escaped) { escaped = false; continue; }
      if (ch === '\\' && inString) { escaped = true; continue; }
      if (ch === '"') { inString = !inString; continue; }
      if (inString) continue;
      if (ch === '{') depth++;
      else if (ch === '}') {
        depth--;
        if (depth === 0) {
          try { return JSON.parse(text.substring(jsonStart, i + 1)); }
          catch { return null; }
        }
      }
    }
    return null;
  }

  function extractBalancedArray(text, startIdx) {
    const arrStart = text.indexOf('[', startIdx);
    if (arrStart === -1) return null;
    let depth = 0;
    let inString = false;
    let escaped = false;
    for (let i = arrStart; i < text.length; i++) {
      const ch = text[i];
      if (escaped) { escaped = false; continue; }
      if (ch === '\\' && inString) { escaped = true; continue; }
      if (ch === '"') { inString = !inString; continue; }
      if (inString) continue;
      if (ch === '[') depth++;
      else if (ch === ']') {
        depth--;
        if (depth === 0) {
          try { return JSON.parse(text.substring(arrStart, i + 1)); }
          catch { return null; }
        }
      }
    }
    return null;
  }

  // ─── Method 1: Page bridge (MAIN world) ────────────────────────────

  async function getCaptionTracksFromPageBridge() {
    for (let attempt = 0; attempt < 3; attempt++) {
      const result = await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          window.removeEventListener('ytai-player-data-response', handler);
          resolve(null);
        }, 2000);

        function handler(event) {
          clearTimeout(timeout);
          window.removeEventListener('ytai-player-data-response', handler);
          try {
            const payload = JSON.parse(event.detail);
            if (payload?.tracks && Array.isArray(payload.tracks) && payload.tracks.length > 0) {
              const currentVid = getVideoId();
              if (payload.videoId && payload.videoId !== currentVid) {
                console.warn(LOG, 'Bridge returned stale data:', payload.videoId, '!==', currentVid);
                resolve(null);
                return;
              }
              resolve(payload.tracks.map(mapRawTrack));
            } else {
              resolve(null);
            }
          } catch {
            resolve(null);
          }
        }

        window.addEventListener('ytai-player-data-response', handler);
        window.dispatchEvent(new CustomEvent('ytai-request-player-data'));
      });

      if (result) {
        console.log(LOG, `Page bridge: ${result.length} tracks found`);
        return result;
      }

      if (attempt < 2) {
        await new Promise((r) => setTimeout(r, 800));
      }
    }
    console.warn(LOG, 'Page bridge: no response after retries');
    return null;
  }

  // ─── Method 2: Script-tag parsing ──────────────────────────────────

  function extractTracksFromPageScripts() {
    try {
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const text = script.textContent;
        if (!text || !text.includes('"captionTracks"')) continue;
        const idx = text.indexOf('"captionTracks"');
        const colonIdx = text.indexOf(':', idx + 15);
        if (colonIdx === -1) continue;

        const tracks = extractBalancedArray(text, colonIdx);
        if (tracks && Array.isArray(tracks) && tracks.length > 0) {
          console.log(LOG, `Script tags: ${tracks.length} tracks found`);
          return tracks.map(mapRawTrack);
        }
      }
    } catch (e) {
      console.warn(LOG, 'Script tag parsing error:', e);
    }
    console.warn(LOG, 'Script tags: no tracks found');
    return null;
  }

  // ─── Method 3: Service-worker proxy (fetches page & parses) ────────

  async function fetchCaptionTracksViaProxy() {
    try {
      const videoId = getVideoId();
      if (!videoId) return null;
      const response = await chrome.runtime.sendMessage({
        action: 'fetchCaptionTracks',
        videoId
      });
      if (response?.tracks && response.tracks.length > 0) {
        console.log(LOG, `SW proxy: ${response.tracks.length} tracks found`);
        return response.tracks;
      }
    } catch (e) {
      console.warn(LOG, 'SW proxy fetchCaptionTracks error:', e);
    }
    console.warn(LOG, 'SW proxy: no tracks');
    return null;
  }

  // ─── Orchestrator: get caption tracks ──────────────────────────────

  async function getCaptionTracks() {
    const bridgeTracks = await getCaptionTracksFromPageBridge();
    if (bridgeTracks?.length) return bridgeTracks;

    const scriptTracks = extractTracksFromPageScripts();
    if (scriptTracks?.length) return scriptTracks;

    return await fetchCaptionTracksViaProxy();
  }

  // ─── Transcript fetching ───────────────────────────────────────────

  function parseJSON3Events(data) {
    if (!data?.events) return null;
    const entries = data.events
      .filter((ev) => ev.segs)
      .map((ev) => {
        const startMs = ev.tStartMs || 0;
        const text = ev.segs.map((s) => s.utf8).join('').replace(/\n/g, ' ').trim();
        return { start: startMs / 1000, startFormatted: formatTimestamp(startMs / 1000), text };
      })
      .filter((e) => e.text.length > 0);
    return entries.length > 0 ? entries : null;
  }

  async function fetchTranscriptDirect(trackUrl) {
    // JSON3
    try {
      const url = new URL(trackUrl);
      url.searchParams.set('fmt', 'json3');
      const resp = await fetch(url.toString());
      if (resp.ok) {
        const entries = parseJSON3Events(await resp.json());
        if (entries) {
          console.log(LOG, `Direct JSON3: ${entries.length} entries`);
          return entries;
        }
      }
    } catch (e) {
      console.warn(LOG, 'Direct JSON3 failed:', e);
    }

    // XML fallback
    try {
      const resp = await fetch(trackUrl);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const xmlText = await resp.text();
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
      const textNodes = xmlDoc.querySelectorAll('text');
      const entries = Array.from(textNodes)
        .map((node) => {
          const start = parseFloat(node.getAttribute('start') || '0');
          const text = node.textContent.replace(/\n/g, ' ').trim();
          return { start, startFormatted: formatTimestamp(start), text };
        })
        .filter((e) => e.text.length > 0);
      if (entries.length > 0) {
        console.log(LOG, `Direct XML: ${entries.length} entries`);
        return entries;
      }
    } catch (e) {
      console.warn(LOG, 'Direct XML failed:', e);
    }
    return null;
  }

  async function fetchTranscriptViaProxy(trackUrl) {
    try {
      const response = await chrome.runtime.sendMessage({
        action: 'fetchTranscript',
        url: trackUrl
      });
      if (response?.entries?.length > 0) {
        console.log(LOG, `SW proxy transcript: ${response.entries.length} entries`);
        return response.entries.map((e) => ({
          ...e,
          startFormatted: formatTimestamp(e.start)
        }));
      }
    } catch (e) {
      console.warn(LOG, 'SW proxy transcript error:', e);
    }
    return null;
  }

  // ─── Track selection ───────────────────────────────────────────────

  function selectBestTrack(tracks, preferredLang = 'auto') {
    if (!tracks?.length) return null;

    if (preferredLang !== 'auto') {
      const exact = tracks.find((t) => t.language === preferredLang && !t.isAutoGenerated);
      if (exact) return exact;
      const autoGen = tracks.find((t) => t.language === preferredLang && t.isAutoGenerated);
      if (autoGen) return autoGen;
    }

    const manual = tracks.find((t) => !t.isAutoGenerated);
    if (manual) return manual;

    const english = tracks.find((t) => t.language === 'en');
    if (english) return english;

    return tracks[0];
  }

  // ─── Main entry point ─────────────────────────────────────────────

  async function getTranscript(preferredLang = 'auto') {
    const videoId = getVideoId();
    if (!videoId) throw new Error('NO_VIDEO_ID');

    const cached = await StorageHelper.getCachedTranscript(videoId);
    if (cached) {
      console.log(LOG, 'Using cached transcript for', videoId);
      return cached;
    }

    const tracks = await getCaptionTracks();
    if (!tracks?.length) throw new Error('NO_TRANSCRIPT');

    const selectedTrack = selectBestTrack(tracks, preferredLang);
    if (!selectedTrack) throw new Error('NO_TRANSCRIPT');

    console.log(LOG, 'Selected track:', selectedTrack.language,
      selectedTrack.isAutoGenerated ? '(auto)' : '(manual)');

    // Try direct fetch first, then service-worker proxy
    let entries = await fetchTranscriptDirect(selectedTrack.baseUrl);
    if (!entries) {
      console.log(LOG, 'Direct fetch failed, trying service-worker proxy…');
      entries = await fetchTranscriptViaProxy(selectedTrack.baseUrl);
    }

    if (!entries?.length) throw new Error('EMPTY_TRANSCRIPT');

    const fullText = entries.map((e) => e.text).join(' ');
    const result = {
      videoId,
      entries,
      fullText,
      language: selectedTrack.language,
      trackName: selectedTrack.name,
      isAutoGenerated: selectedTrack.isAutoGenerated,
      availableTracks: tracks.map((t) => ({
        language: t.language,
        name: t.name,
        isAutoGenerated: t.isAutoGenerated
      }))
    };

    await StorageHelper.cacheTranscript(videoId, result);
    return result;
  }

  async function getAvailableLanguages() {
    const tracks = await getCaptionTracks();
    if (!tracks) return [];
    return tracks.map((t) => ({ code: t.language, name: t.name, isAutoGenerated: t.isAutoGenerated }));
  }

  return {
    getVideoId,
    getTranscript,
    getAvailableLanguages,
    formatTimestamp
  };
})();

if (typeof window !== 'undefined') {
  window.TranscriptExtractor = TranscriptExtractor;
}
